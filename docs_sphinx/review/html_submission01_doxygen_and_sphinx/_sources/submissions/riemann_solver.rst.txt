
.. _submissions_riemann_solver:

.. role:: raw-html(raw)
    :format: html

1. Riemann Solver
====================

F-wave Solver
-------------

Header file: ``.../Tsunami-Simulation/include/solvers/FWave.h``

Implementation file: ``.../Tsunami-Simulation/src/solvers/FWave.cpp``

Test file: ``.../Tsunami-Simulation/src/solvers/FWave.test.cpp``

The f-wave solver approximately solves the following Initial Value Problem (IVP) for the shallow water equations over time:

:raw-html:`<center>(1.3.1)</center>`

.. math::
    \begin{split}q(x,0) =
      \begin{cases}
        q_{l} \quad   &\text{if } x < 0 \\
        q_{r} \quad &\text{if }   x > 0
      \end{cases} \qquad q_l, q_r \in \mathbb{R}^+ \times \mathbb{R}.\end{split}

Theory shows that the solution, arising from the discontinuity at :math:`x=0`,
consist of two waves. Each wave is either a shock or a rarefaction wave.
The f-wave solver uses two shock waves to approximate the true solution.

First, we use the Roe eigenvalues :math:`\lambda^{\text{Roe}}_{1/2}` in terms
of the left and right quantities :math:`q_l` and :math:`q_r` with respect to
position :math:`x=0` to approximate the true wave speeds:

:raw-html:`<center>(1.3.2)</center>`

.. math::
    \begin{split}\begin{aligned}
      \lambda^{\text{Roe}}_{1}(q_l, q_r) &= u^{\text{Roe}}(q_l, q_r) - \sqrt{gh^{\text{Roe}}(q_l, q_r)}, \\
      \lambda^{\text{Roe}}_{2}(q_l, q_r) &= u^{\text{Roe}}(q_l, q_r) + \sqrt{gh^{\text{Roe}}(q_l, q_r)},
    \end{aligned}\end{split}

where the height :math:`h^{\text{Roe}}` and particle velocity :math:`u^{\text{Roe}}`
are given as:

.. math::
    \begin{split}\begin{aligned}
      h^{\text{Roe}}(q_l, q_r) &= \frac{1}{2} (h_l + h_r), \\
      u^{\text{Roe}}(q_l, q_r) &=  \frac{u_l \sqrt{h_l} + u_r \sqrt{h_r}}{\sqrt{h_l}+\sqrt{h_r}}.
    \end{aligned}\end{split}

.. code-block:: bash

    void tsunami_lab::solvers::FWave::computeEigenvalues(t_real   i_hL,
                                                         t_real   i_hR,
                                                         t_real   i_uL,
                                                         t_real   i_uR,
                                                         t_real & o_eigenvalue1,
                                                         t_real & o_eigenvalue2){
        // pre-compute square-root ops
        t_real l_hSqrtL = std::sqrt( i_hL );
        t_real l_hSqrtR = std::sqrt( i_hR );

        // compute averages
        t_real l_h = 0.5f * ( i_hL + i_hR );
        t_real l_u = l_hSqrtL * i_uL + l_hSqrtR * i_uR;
        l_u /= l_hSqrtL + l_hSqrtR;

        // compute eigenvalues
        t_real l_ghSqrtRoe = m_gSqrt * std::sqrt( l_h );
        o_eigenvalue1 = l_u - l_ghSqrtRoe;
        o_eigenvalue2 = l_u + l_ghSqrtRoe;
    }

.. math::
    \begin{split}\begin{aligned}
      r_1^{\text{Roe}} &=
        \begin{bmatrix}
          1 \\ \lambda^{\text{Roe}}_1
        \end{bmatrix}, \\
      r_2^{\text{Roe}} &=
        \begin{bmatrix}
          1 \\ \lambda^{\text{Roe}}_2
        \end{bmatrix}.
    \end{aligned}\end{split}

Compute flux function:

.. math::
    f := [hu, hu^2 + \frac{1}{2}gh^2]^T \\
    \Delta f := f(q_r) - f(q_l)

.. code-block:: bash

    void tsunami_lab::solvers::FWave::computeDeltaFlux(t_real i_hL,
                                                       t_real i_hR,
                                                       t_real i_uL,
                                                       t_real i_uR,
                                                       t_real o_deltaFlux[2]){
        t_real i_huL = i_hL * i_uL;
        t_real i_huR = i_hR * i_uR;

        o_deltaFlux[0] = i_huR - i_huL;
        o_deltaFlux[1] = (i_hR * i_uR * i_uR + 0.5f * m_g * i_hR * i_hR)
                        -(i_hL * i_uL * i_uL + 0.5f * m_g * i_hL * i_hL);
    }

The eigencoefficients :math:`\alpha_p` in Equation are obtained by
multiplying the inverse of the matrix of right eigenvectors :math:`R=[r_1^\text{Roe}, r_2^\text{Roe}]`
with the jump in fluxes:

.. math::
    \begin{split}\begin{bmatrix}
      \alpha_1 \\
      \alpha_2
    \end{bmatrix} =
    \begin{bmatrix}
      1 & 1 \\
      \lambda^{\text{Roe}}_1 & \lambda^{\text{Roe}}_2
    \end{bmatrix}^{-1} \Delta f.\end{split}

.. code-block:: bash

    void tsunami_lab::solvers::FWave::computeEigencoefficients(t_real i_eigenvalue1,
                                                               t_real i_eigenvalue2,
                                                               t_real i_deltaFlux[2],
                                                               t_real &o_eigencoefficient1,
                                                               t_real &o_eigencoefficient2) {
        // compute inverse matrix
        t_real denominator = i_eigenvalue2 - i_eigenvalue1;
        t_real invertedMatrix[2][2] = {
                {i_eigenvalue2 / denominator, -1 / denominator},
                {-i_eigenvalue1 / denominator, 1 / denominator}
        };

        // compute eigencoefficients
        o_eigencoefficient1 = invertedMatrix[0][0] * i_deltaFlux[0] + invertedMatrix[0][1] * i_deltaFlux[1];
        o_eigencoefficient2 = invertedMatrix[1][0] * i_deltaFlux[0] + invertedMatrix[1][1] * i_deltaFlux[1];
    }

Using the eigenvalues we can define corresponding eigenvectors :math:`r_{1/2}^{\text{Roe}}`

.. math::
    \begin{split}\begin{aligned}
      r_1^{\text{Roe}} &=
        \begin{bmatrix}
          1 \\ \lambda^{\text{Roe}}_1
        \end{bmatrix}, \\
      r_2^{\text{Roe}} &=
        \begin{bmatrix}
          1 \\ \lambda^{\text{Roe}}_2
        \end{bmatrix}.
    \end{aligned}\end{split}

Using the eigenvectors and our eigencoefficients we can compute
the waves :math:`Z_{1/2}`

:raw-html:`<center>(1.3.3)</center>`

.. math::
    \Delta f = \sum_{p=1}^2 \alpha_p r_p \equiv  \sum_{p=1}^2 Z_p, \qquad \alpha_p \in \mathbb{R}.

This leads to the definition of net updates which summarize the
net effect of the waves to the left and right “cell”:

.. math::
    \begin{split}\begin{split}
      A^- \Delta Q := \sum_{p:\{ \lambda_p^\text{Roe} < 0 \}} Z_p \\
      A^+ \Delta Q := \sum_{p:\{ \lambda_p^\text{Roe} > 0 \}} Z_p
    \end{split}\end{split}

.. code-block:: bash

    void tsunami_lab::solvers::FWave::netUpdates(t_real i_hL,
                                                 t_real i_hR,
                                                 t_real i_huL,
                                                 t_real i_huR,
                                                 t_real *o_netUpdateL,
                                                 t_real *o_netUpdateR) {

        // compute particle velocities
        t_real l_uL = i_huL / i_hL;
        t_real l_uR = i_huR / i_hR;

        // compute eigenvalues
        t_real eigenvalue1 = 0;
        t_real eigenvalue2 = 0;
        computeEigenvalues(i_hL, i_hR, l_uL, l_uR, eigenvalue1, eigenvalue2);

        // create eigenvectors
        t_real eigenvector1[2] = {1, eigenvalue1};
        t_real eigenvector2[2] = {1, eigenvalue2};

        // compute delta flux
        t_real deltaFlux[2];
        computeDeltaFlux(i_hL, i_hR, l_uL, l_uR, deltaFlux);

        // compute eigencoefficients
        t_real eigencoefficient1 = 0;
        t_real eigencoefficient2 = 0;
        computeEigencoefficients(eigenvalue1, eigenvalue2, deltaFlux, eigencoefficient1, eigencoefficient2);

        // compute waves / net updates
        for( unsigned short l_qt = 0; l_qt < 2; l_qt++ )
        {
            // init
            o_netUpdateL[l_qt] = 0;
            o_netUpdateR[l_qt] = 0;

            // 1st wave
            if( eigenvalue1 < 0 )
            {
                o_netUpdateL[l_qt] += eigencoefficient1 * eigenvector1[l_qt];
            }
            else
            {
                o_netUpdateR[l_qt] += eigencoefficient1 * eigenvector1[l_qt];
            }

            // 2nd wave
            if( eigenvalue2 < 0 )
            {
                o_netUpdateL[l_qt] += eigencoefficient2 * eigenvector2[l_qt];
            }
            else
            {
                o_netUpdateR[l_qt] += eigencoefficient2 * eigenvector2[l_qt];
            }
        }
    }


Sphinx with Doxygen
-------------------

1. First we install ``Doxygen``.

2. We install ``Sphinx`` and ``breathe`` and set breath as an extension. An installation guide can be found at `Building the Documentation`_.
    
    .. code-block:: python

        extensions = [
            ...
            'breathe',
            ...
        ]

3. We set up the Doxyfile by setting the variables
    
    .. code-block::

        ...
        OUTPUT_DIRECTORY       = "_build"
        ...
        INPUT                  = "../include/"
        ...
        RECURSIVE              = YES
        ...
        GENERATE_XML           = YES
        ...

    ``GENERATE_XML`` is need, because breathe uses the xml files to generate the respective sphinx files.

4. We include the following code at the top of the ``conf.py`` to build the doxygen documentation together with sphinx.

    .. code-block:: python

        import subprocess

        subprocess.call('doxygen Doxyfile.in', shell=True)

5. We set up breathe by adding the following configurations to the ``conf.py``

    .. code-block:: python

        # -- Breathe configuration -------------------------------------------------

        breathe_projects = {
            "Tsunami Simulation": "_build/xml/",
        }

        breathe_default_project = "Tsunami Simulation"
        breathe_default_members = ('members', 'undoc-members')

6. Now we can include a whole namespace e.g. the *tsunami_lab::io* namespace into sphinx

    .. code-block:: rst

        .. doxygennamespace:: tsunami_lab::io
            :project: Tsunami Simulation
            :content-only:
            :members:
            :private-members:
            :undoc-members:
    
    More information about directives to include the doxygen into sphinx can be found at the `official breathe website <https://breathe.readthedocs.io/en/latest/directives.html>`_.


Contribution
------------

All team members contributed equally to the tasks.